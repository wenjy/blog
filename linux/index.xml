<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linuxes on Wenjy&#39;s Blog</title><link>https://blog.wenjy.top/linux/</link><description>Recent content in Linuxes on Wenjy&#39;s Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 11 Oct 2019 22:29:21 +0800</lastBuildDate><atom:link href="https://blog.wenjy.top/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Lock</title><link>https://blog.wenjy.top/linux/lock/</link><pubDate>Fri, 11 Oct 2019 22:29:21 +0800</pubDate><guid>https://blog.wenjy.top/linux/lock/</guid><description>《操作系统之哲学原理》-锁 死锁的4个必要条件 死锁发生的必要条件是 资源有限
持有等待
不能抢占资源
循环等待条件
哲学家就餐问题 哲学家每天只做两家事情：思考 吃饭 吃饭规矩：哲学家围在一张圆桌边，每个人的左右两边均放着一根筷子。如果要吃饭，需要获得左右 的筷子（不能用一根筷子吃饭）
运行的算法：
等待左边的筷子可用，然后拿起左边的筷子 等待右边的筷子可用，然后拿起右边的筷子 吃饭 放下两根筷子 如果每个哲学家穿插执行，将出现每个哲学家都拿起左边筷子，而等待右边筷子的情况，死锁将发生。
死锁的应对 两种策略：
一、允许死锁发生
假装没看见，不予理睬 死锁发生的概率比较低，防止死锁的代价很高，还不如重启
2.在死锁发生后，想办法予以解决(基本行不通，检测死锁不能肯定死锁发生、可能检测死锁的线程自己发生了死锁)
首先需要检测死锁，利用资源分配矩阵、资源等待矩阵、系统总资源、当前系统可用资源
死锁恢复，可用使用抢占、终止占用最多资源的线程、杀掉整个线程、rollback
动态避免 在每次进行资源分配时，必须经过仔细的计算，确保该资源请求批准后系统不会进入死锁或者潜在死锁状态
系统当前可用资源：3
线程 已持有 总需求 A 3 9 B 2 4 C 2 7 这个状态是否是安全状态？答案是 是安全状态</description></item></channel></rss>