<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=generator content="Hugo 0.68.1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>Lock | Wenjy's Blog</title><meta property="og:title" content="Lock - Wenjy's Blog"><meta property="og:type" content="article"><meta property="article:published_time" content="2019-10-11T22:29:21+08:00"><meta property="article:modified_time" content="2019-10-11T22:29:21+08:00"><meta name=Keywords content="PHP,Swoole,Web开发"><meta name=description content="Lock"><meta name=author content="江湖义气"><meta property="og:url" content="https://blog.wenjy.top/linux/lock/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/prism.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://blog.wenjy.top>Wenjy's Blog</a><p class=description>回首往事，不会因为虚度年华而悔恨，也不会因为碌碌无为而感到羞愧。</p></div><div><nav id=nav-menu class=clearfix><a href=https://blog.wenjy.top>首页</a>
<a href=https://blog.wenjy.top/archives title=归档>归档</a>
<a href=https://blog.wenjy.top/about title=关于>关于</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Lock</h1></header><date class="post-meta meta-date">2019年10月11日</date><div class=post-meta><span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span> 阅读</span></span></div><div class=post-content><h2 id=操作系统之哲学原理-锁>《操作系统之哲学原理》-锁</h2><h3 id=死锁的4个必要条件>死锁的4个必要条件</h3><ol><li><p>死锁发生的必要条件是 资源有限</p></li><li><p>持有等待</p></li><li><p>不能抢占资源</p></li><li><p>循环等待条件</p></li></ol><h3 id=哲学家就餐问题>哲学家就餐问题</h3><ul><li>哲学家每天只做两家事情：思考 吃饭</li></ul><blockquote><p>吃饭规矩：哲学家围在一张圆桌边，每个人的左右两边均放着一根筷子。如果要吃饭，需要获得左右
的筷子（不能用一根筷子吃饭）</p></blockquote><p>运行的算法：</p><ol><li>等待左边的筷子可用，然后拿起左边的筷子</li><li>等待右边的筷子可用，然后拿起右边的筷子</li><li>吃饭</li><li>放下两根筷子</li></ol><p>如果每个哲学家穿插执行，将出现每个哲学家都拿起左边筷子，而等待右边筷子的情况，死锁将发生。</p><h3 id=死锁的应对>死锁的应对</h3><p>两种策略：</p><p>一、允许死锁发生</p><ol><li>假装没看见，不予理睬</li></ol><blockquote><p>死锁发生的概率比较低，防止死锁的代价很高，还不如重启</p></blockquote><p>2.在死锁发生后，想办法予以解决(基本行不通，检测死锁不能肯定死锁发生、可能检测死锁的线程自己发生了死锁)</p><blockquote><p>首先需要检测死锁，利用资源分配矩阵、资源等待矩阵、系统总资源、当前系统可用资源</p></blockquote><blockquote><p>死锁恢复，可用使用抢占、终止占用最多资源的线程、杀掉整个线程、rollback</p></blockquote><ol start=3><li>动态避免</li></ol><blockquote><p>在每次进行资源分配时，必须经过仔细的计算，确保该资源请求批准后系统不会进入死锁或者潜在死锁状态</p></blockquote><p>系统当前可用资源：3</p><table><thead><tr><th>线程</th><th>已持有</th><th>总需求</th></tr></thead><tbody><tr><td>A</td><td>3</td><td>9</td></tr><tr><td>B</td><td>2</td><td>4</td></tr><tr><td>C</td><td>2</td><td>7</td></tr></tbody></table><p>这个状态是否是安全状态？答案是 是安全状态</p><p>B先运行 取得2个系统资源运行结束，系统资源为 5
C运行，取5个系统资源运行结束，系统资源为 7
A运行，取6个系统资源运行结束</p><p>系统当前可用资源：2</p><table><thead><tr><th>线程</th><th>已持有</th><th>总需求</th></tr></thead><tbody><tr><td>A</td><td>4</td><td>9</td></tr><tr><td>B</td><td>2</td><td>4</td></tr><tr><td>C</td><td>2</td><td>7</td></tr></tbody></table><p>谁先执行都会发送死锁</p><p>难题所在：不能准确的预测线程的最大资源需求，只能粗略估算，如果计算超额会浪费资源，更为严重的是会
造成死锁误判，因为安全不安全的状态判断依据之一就是最大资源需求。如果估算过大，超过线程的实际资源需求
将造成在实际安全的情况下，系统被判为不安全，从而造成可以执行的任务也得不到执行</p><p>二、不允许死锁发生
仔细检查，避免死锁发生
通过将发生死锁的必要条件消除，避免死锁发生</p><h3 id=消除死锁的必要条件>消除死锁的必要条件</h3><ol><li><p>将资源无限增加、把资源变为共享，无限是不现实的，资源共享适合部分资源，例如键盘输入就无法共享</p></li><li><p>一个线程必须一次请求其所需要的所有资源，而不是一般情况下的请求一点资源做一点事情，缺点是不利于资源的有效利用。</p></li></ol><p>一种变通的方法是，还像以前那样请求资源，不过如果请求的资源被拒绝，则该线程需要将其现在已经拥有的资源也释放。
这样的缺点是，本来完成了一半的工作，因为某个资源获取不到而放弃了以前的全部工作，也会造成浪费</p><ol start=3><li><p>允许抢占资源，如CPU和内存，但也不是所有的资源都能抢占，例如锁就不能抢占</p></li><li><p>出现循环等待的原因就是因为线程请求资源的顺序是随机的，我们可以规定资源的请求顺序</p></li></ol><p>解决哲学家吃饭问题</p><ol><li>杜绝循环等待：对筷子编号123456，拿筷子的人必须按照这个顺序拿</li><li>杜绝保持并等待：要求要么同时拿起两根筷子，要么一根都不拿</li><li>动态避免：在拿起一根筷子时，判断他是否可以拿起这根筷子，有哲学家在吃饭或者这根筷子后还有多余的筷子</li></ol><h3 id=锁的实现>锁的实现</h3><p>硬件实现的原子操作(指令)：</p><ol><li>中断禁止、启用(interrupt disable/enable)，这个操作由操作系统封装成锁</li><li>内存加载、存入(load/store)</li><li>测试与设置(test&set)</li></ol><p>一、以中断启用与禁止来实现锁</p><blockquote><p>进程切换必须发生上下文切换，而发生上下文切换只能有两种可能：线程自愿(yield)放弃CPU而将控制权交个操作系统调度器，
另一个是线程被强制（周期性的时钟中断）放弃CPU而失去控制权</p></blockquote><p>获得锁的伪代码：</p><pre><code>lock() {
    // 先禁止中断
    disable interrupts;
    // 检查 value，如果是FREE表示这个资源没有被占用
    // 循环等待为 FREE
    while (value != FREE) {
        // 启用中断让其它进程有将 value 设置为 FREE时间
        enable interrupts;
        // 这中间是其它进程的时间
        disable interrupts;
    }
    // 设置为 BUSY 开启中断
    value = BUSY;
    enable interrupts;
}
</code></pre><p>释放锁：</p><pre><code>unlock() {
    // value 赋值为 FREE 需要中断保护，因为赋值语句不是原子操作
    disable interrupts;
    value = FREE;
    enable interrupts;
}
</code></pre><p>缺点：频繁的中断可能造成对重要的事件处理不及时，在锁的实现中留给其它进程获得CPU的机会也不大</p><p>二、以测试与设置指令来实现锁</p><blockquote><p>原子操作：将内存指定位置的存储单元的内容读取到寄存器，将新的值写入到刚才的内存单元;
test&set 将值写入指定的内存单元，并返回内存单元原来的值</p></blockquote><pre><code>test_and_set(X) {
    tmp = X;
    X = 1;
    return tmp;
}

lock() {
    while(test_and_set(value) == 1) {
    
    }
}

// 调用unlock的进程移动是已经获得锁的，所以不需要保护
unlock() {
    value = 0;
}
</code></pre><p>三、以非繁忙等待、中断启用与禁止来实现锁</p><blockquote><p>一和二的两种锁的实现都有繁忙等待的问题，繁忙等待浪费资源，并且有可能造成优先级倒挂和死锁</p></blockquote><ol><li>使用中断禁止，但不进行繁忙等待。</li><li>如果拿不到锁，等待进程放弃CPU并进入睡眠状态，以便持有锁的进程可以更好的运行</li><li>当释放锁的时候将睡眠进程叫醒</li></ol><p>错误的方式:</p><pre><code>lock (){
    // 如果别的线程没有执行中断，那么系统将进入死锁状态
    disable interrupts;
    if (value == FREE) {
        value = BUSY;
    } else {
        // 加入该锁的队列
        add thread to queue of threads waiting for this lock;
        // 切换进程
        switch to next runable thread;
    }
    enable interrupts;
}
</code></pre><p>只能要求所有的线程遵循下列约定：</p><ul><li><p>所有线程承诺在调用线程切换是将中断留在禁止状态</p></li><li><p>所有线程承诺在从切换返回是将中断重启启用</p></li></ul><p>但是依赖别人来遵循是很危险的</p><p>四、以最少繁忙等待、测试与设置来实现锁</p><blockquote><p>只用繁忙等待来执行闭锁操作，如果不能获得锁就得放弃CPU</p></blockquote><pre><code>lock() {
    while(test_and_set(guard)) {
        
    }
    
    if (value == FREE) {
        value = BUSY;
        guard = 0;
    } else {
        // 加入该锁的队列
        add thread to queue of threads waiting for this lock;
        guard = 0;
        // 切换进程
        switch to next runable thread;
    }
}

unlock() {
    while(test_and_set(guard)) {
            
    }
    
    value = FREE;
    
    if (any thread is waiting for this lock) {
        move waiting thread from waiting queue to ready queue;
        value = BUSY;
    }
    guard = 0;
}
</code></pre></div><div class=post-archive><h2>See Also</h2><ul class=listing><li><a href=/php/php7-array/>PHP7 Array</a></li><li><a href=/archives/>Archives</a></li><li><a href=/about/>About</a></li></ul></div><div class="post-meta meta-tags">没有标签</div></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=wenjy/blog issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://blog.wenjy.top>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>分类</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>标签</h3><div class=tagcloud></div></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://mikelin.cn title="MIKELIN | 关注科技，弘扬互联网精神！">MIKELIN</a></li><li><a target=_blank href=https://blog.wenjy.top title=江湖义气的网络日志>江湖义气的网络日志</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://blog.wenjy.top/index.xml>文章 RSS</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href=https://blog.wenjy.top>Wenjy's Blog By 江湖义气</a>.
Powered by <a rel="nofollow noreferer noopener" href=https://gohugo.io target=_blank>Hugo</a>.
<a href=https://www.flysnow.org/ target=_blank>Theme</a> based on <a href=https://github.com/rujews/maupassant-hugo target=_blank>maupassant</a>.</div></footer><script type=text/javascript>(function(){$("pre code").parent().addClass("line-numbers")}());window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script type=text/javascript src=/js/prism.js async></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src="/js/totop.js?v=0.0.0" async></script><script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async></script></body></html>