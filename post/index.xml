<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 江湖义气的博客</title><link>https://blog.wenjy.top/post/</link><description>Recent content in Posts on 江湖义气的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 11 Oct 2019 22:31:57 +0800</lastBuildDate><atom:link href="https://blog.wenjy.top/post/index.xml" rel="self" type="application/rss+xml"/><item><title>工作中遇到的问题+踩过的坑</title><link>https://blog.wenjy.top/post/2019-1-1-work/</link><pubDate>Fri, 11 Oct 2019 22:31:57 +0800</pubDate><guid>https://blog.wenjy.top/post/2019-1-1-work/</guid><description>安装的虚拟机时间不同步 ntpdate cn.pool.ntp.org phpxdebug 运行失败，端口繁忙 因为 phpxdebug 端口和 php 默认监听的端口冲突，都是默认9000 把 phpxdebug port 设置为 9001
本地测试环境curl，https时因为没有设置公钥而失败 设置 2019.4.15 yar Yar_Client 报错：curl exec failed &amp;lsquo;Timeout was reached&amp;rsquo; 2019.4.16 phpstudy 的PHP默认是32位的，long2ip() 时会有问题，需要换装64位的 reids 也是32位，溢出问题 直接替换 phpstudy 的 php 为 64位版本的，但是 redis 在win上没有，最后使用虚拟机了
2019.4.17 升级框架，laravel/lumen 5.</description></item><item><title>Mysql 索引学习</title><link>https://blog.wenjy.top/post/2019-10-11-mysql-index/</link><pubDate>Fri, 11 Oct 2019 22:30:57 +0800</pubDate><guid>https://blog.wenjy.top/post/2019-10-11-mysql-index/</guid><description>一、索引 索引的类型（数据结构） 1. B-Tree 所有引擎都支持
InnoDB(根据主键引用被索引的行，索引和数据同一个文件)、MyISAM(通过数据的物理位置应用被索引的行，索引和数据是不同的文件)
多列索引 需要满足最左原则，where条件必须和索引的顺序一致，如果只用到单列则必须是最左列
InnoDB使用聚簇索引（一种数据存储方式） 聚簇索引的表现形式为，二级索引里包含了主键列（二级索引的行指针是指向行的主键值而不是行的物理地址），所以使用InnoDB时应该尽可能建一个递增的（顺序主键）如果没有则会隐式定义一个主键来作为聚簇索引
覆盖索引 如果一个索引包含所有需要查询的字段的值
使用索引扫描来做排序 只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。也需要满足索引的最左前缀要求（例外：前导列为常量的时候）。
建如下表测试索引排序
CREATE TABLE `test` ( `id` int(11) NOT NULL AUTO_INCREMENT, `realname` varchar(10) NOT NULL DEFAULT '', `sex` tinyint(4) NOT NULL DEFAULT '0', `age` tinyint(4) NOT NULL DEFAULT '0', `job` varchar(10) NOT NULL DEFAULT '', PRIMARY KEY (`id`), KEY `test_realname_sex_age_index` (`realname`,`sex`,`age`), KEY `sex_index` (`sex`), KEY `age_index` (`age`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8</description></item><item><title>Linux Lock的原理</title><link>https://blog.wenjy.top/post/2019-10-11-linux-lock/</link><pubDate>Fri, 11 Oct 2019 22:29:21 +0800</pubDate><guid>https://blog.wenjy.top/post/2019-10-11-linux-lock/</guid><description>《操作系统之哲学原理》-锁 死锁的4个必要条件 死锁发生的必要条件是 资源有限
持有等待
不能抢占资源
循环等待条件
哲学家就餐问题 哲学家每天只做两家事情：思考 吃饭 吃饭规矩：哲学家围在一张圆桌边，每个人的左右两边均放着一根筷子。如果要吃饭，需要获得左右 的筷子（不能用一根筷子吃饭）
运行的算法：
等待左边的筷子可用，然后拿起左边的筷子 等待右边的筷子可用，然后拿起右边的筷子 吃饭 放下两根筷子 如果每个哲学家穿插执行，将出现每个哲学家都拿起左边筷子，而等待右边筷子的情况，死锁将发生。
死锁的应对 两种策略：
一、允许死锁发生
假装没看见，不予理睬 死锁发生的概率比较低，防止死锁的代价很高，还不如重启
2.在死锁发生后，想办法予以解决(基本行不通，检测死锁不能肯定死锁发生、可能检测死锁的线程自己发生了死锁)
首先需要检测死锁，利用资源分配矩阵、资源等待矩阵、系统总资源、当前系统可用资源
死锁恢复，可用使用抢占、终止占用最多资源的线程、杀掉整个线程、rollback
动态避免 在每次进行资源分配时，必须经过仔细的计算，确保该资源请求批准后系统不会进入死锁或者潜在死锁状态</description></item><item><title>PHP7数组的实现</title><link>https://blog.wenjy.top/post/2019-10-11-php7-array/</link><pubDate>Fri, 11 Oct 2019 22:29:21 +0800</pubDate><guid>https://blog.wenjy.top/post/2019-10-11-php7-array/</guid><description>PHP数组是一个有序的字典，它必须同时满足下面两个语义 PHP数组是一个字典，存储着键-值（key-value）对，通过键可以快速地找到对应的值，键可以是整形、字符串。
PHP数组是有序的，这个有序是指插入顺序，即遍历数组的时候，遍历元素的顺序应该和插入的顺序一致。
为了实现语义1，PHP使用 HashTable 来存储 key-value ，但是 HashTable 只能保证语义1
php使用了带h值的 HashTable key/value -&amp;gt; hash1函数 -&amp;gt; h值 -&amp;gt; hash2函数 -&amp;gt; slotN -&amp;gt; bucket()
示意图：
bucket里面增加了 h 字段
hash函数拆分成 hash1 和 hash2 函数，hash1 将 key 映射成 h值，hash2 将 h 值映射为 slot 的索引值</description></item></channel></rss>