<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Wenjy&#39;s Blog</title><link>https://wenjy.top/</link><description>Recent content on Wenjy&#39;s Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 11 Oct 2019 22:31:57 +0800</lastBuildDate><atom:link href="https://wenjy.top/index.xml" rel="self" type="application/rss+xml"/><item><title>Work</title><link>https://wenjy.top/work/</link><pubDate>Fri, 11 Oct 2019 22:31:57 +0800</pubDate><guid>https://wenjy.top/work/</guid><description>工作中遇到的问题+踩过的坑 2019.4.10 安装的虚拟机时间不同步 ntpdate cn.pool.ntp.org 2019.4.11 phpxdebug 运行失败，端口繁忙 因为 phpxdebug 端口和 php 默认监听的端口冲突，都是默认9000
把 phpxdebug port 设置为 9001
本地测试环境curl，https时因为没有设置公钥而失败 设置 2019.4.15 yar Yar_Client 报错：curl exec failed &amp;lsquo;Timeout was reached&amp;rsquo; 2019.4.16 phpstudy 的PHP默认是32位的，long2ip() 时会有问题，需要换装64位的 reids 也是32位，溢出问题 直接替换 phpstudy 的 php 为 64位版本的，但是 redis 在win上没有，最后使用虚拟机了
2019.4.17 升级框架，laravel/lumen 5.6.* -&amp;gt; 5.8.* 按照5.8.*修改composer.json依赖一致，然后利用gitbug的文件对比功能，修改改变的文件。 使用 github 版本文件对比，修改更改的文件和受影响的改动
Comparing changes
2019.4.18 reids重启后rdb文件没有加载，原因 dir 设置的是 .</description></item><item><title>Mysql</title><link>https://wenjy.top/mysql/</link><pubDate>Fri, 11 Oct 2019 22:30:57 +0800</pubDate><guid>https://wenjy.top/mysql/</guid><description>一、索引 索引的类型（数据结构） 1. B-Tree 所有引擎都支持
InnoDB(根据主键引用被索引的行，索引和数据同一个文件)、MyISAM(通过数据的物理位置应用被索引的行，索引和数据是不同的文件) - 多列索引 需要满足最左原则，where条件必须和索引的顺序一致，如果只用到单列则必须是最左列
InnoDB使用聚簇索引（一种数据存储方式） &amp;gt; 聚簇索引的表现形式为，二级索引里包含了主键列（二级索引的行指针是指向行的主键值而不是行的物理地址），所以使用InnoDB时应该尽可能建一个递增的（顺序主键）如果没有则会隐式定义一个主键来作为聚簇索引
覆盖索引 &amp;gt; 如果一个索引包含所有需要查询的字段的值
使用索引扫描来做排序
只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。也需要满足索引的最左前缀要求（例外：前导列为常量的时候）。
建如下表测试索引排序
CREATE TABLE `test` ( `id` int(11) NOT NULL AUTO_INCREMENT, `realname` varchar(10) NOT NULL DEFAULT &#39;&#39;, `sex` tinyint(4) NOT NULL DEFAULT &#39;0&#39;, `age` tinyint(4) NOT NULL DEFAULT &#39;0&#39;, `job` varchar(10) NOT NULL DEFAULT &#39;&#39;, PRIMARY KEY (`id`), KEY `test_realname_sex_age_index` (`realname`,`sex`,`age`), KEY `sex_index` (`sex`), KEY `age_index` (`age`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 1.</description></item><item><title>Lock</title><link>https://wenjy.top/linux/lock/</link><pubDate>Fri, 11 Oct 2019 22:29:21 +0800</pubDate><guid>https://wenjy.top/linux/lock/</guid><description>《操作系统之哲学原理》-锁 死锁的4个必要条件 死锁发生的必要条件是 资源有限
持有等待
不能抢占资源
循环等待条件
哲学家就餐问题 哲学家每天只做两家事情：思考 吃饭 吃饭规矩：哲学家围在一张圆桌边，每个人的左右两边均放着一根筷子。如果要吃饭，需要获得左右 的筷子（不能用一根筷子吃饭）
运行的算法：
等待左边的筷子可用，然后拿起左边的筷子 等待右边的筷子可用，然后拿起右边的筷子 吃饭 放下两根筷子 如果每个哲学家穿插执行，将出现每个哲学家都拿起左边筷子，而等待右边筷子的情况，死锁将发生。
死锁的应对 两种策略：
一、允许死锁发生
假装没看见，不予理睬 死锁发生的概率比较低，防止死锁的代价很高，还不如重启
2.在死锁发生后，想办法予以解决(基本行不通，检测死锁不能肯定死锁发生、可能检测死锁的线程自己发生了死锁)
首先需要检测死锁，利用资源分配矩阵、资源等待矩阵、系统总资源、当前系统可用资源
死锁恢复，可用使用抢占、终止占用最多资源的线程、杀掉整个线程、rollback
动态避免 在每次进行资源分配时，必须经过仔细的计算，确保该资源请求批准后系统不会进入死锁或者潜在死锁状态
系统当前可用资源：3
线程 已持有 总需求 A 3 9 B 2 4 C 2 7 这个状态是否是安全状态？答案是 是安全状态</description></item><item><title>PHP7 Array</title><link>https://wenjy.top/php/php7-array/</link><pubDate>Fri, 11 Oct 2019 22:29:21 +0800</pubDate><guid>https://wenjy.top/php/php7-array/</guid><description>PHP7数组的实现 PHP数组是一个有序的字典，它必须同时满足下面两个语义 PHP数组是一个字典，存储着键-值（key-value）对，通过键可以快速地找到对应的值，键可以是整形、字符串。
PHP数组是有序的，这个有序是指插入顺序，即遍历数组的时候，遍历元素的顺序应该和插入的顺序一致。
为了实现语义1，PHP使用 HashTable 来存储 key-value ，但是 HashTable 只能保证语义1
php使用了带h值的 HashTable key/value -&amp;gt; hash1函数 -&amp;gt; h值 -&amp;gt; hash2函数 -&amp;gt; slotN -&amp;gt; bucket()
示意图：
bucket里面增加了 h 字段
hash函数拆分成 hash1 和 hash2 函数，hash1 将 key 映射成 h值，hash2 将 h 值映射为 slot 的索引值
bucket 里的 key 作为字符串key
HashTable 的key可能为数字，也可能是字符串，如果是数字那么 h值就代表数字key，如果是字符串，计算出h值，key1和key2比较时 先比较它们的h值是否相等，如果相等在比较key1和key2是否相等，因为大部分场景，不同字符串的h值都不会相等，这样提高了 HashTable 的插入、查找速度。
数组的基本结构 typedef struct _zend_array zend_array; typedef struct _zend_array HashTable; //Bucket：散列表中存储的元素 typedef struct _Bucket { zval val; //存储的具体value，这里嵌入了一个zval，而不是一个指针 zend_ulong h; //key根据times 33计算得到的哈希值，或者是数值索引编号 zend_string *key; //存储元素的key } Bucket; //HashTable结构 typedef struct _zend_array HashTable; struct _zend_array { zend_refcounted_h gc; // 引用计数相关 union { struct { ZEND_ENDIAN_LOHI_4( zend_uchar flags, // zend_uchar nApplyCount, // 递归遍历计数，为了解决循环引用导致死循环的问题 zend_uchar nIteratorsCount, // 迭代器计数器 zend_uchar reserve) } v; uint32_t flags; } u; uint32_t nTableMask; //哈希值计算掩码，等于nTableSize的负值(nTableMask = -nTableSize) Bucket *arData; //存储元素数组，指向第一个Bucket（连续的内存） uint32_t nNumUsed; //已用Bucket数 uint32_t nNumOfElements; //哈希表有效元素数 uint32_t nTableSize; //哈希表总大小，为2的n次方 uint32_t nInternalPointer; // 全局游标 与 reset/key/current/next/prev函数有关 zend_long nNextFreeElement; //下一个可用的数值索引,如:arr[] = 1;arr[&amp;quot;a&amp;quot;] = 2;arr[] = 3; 则nNextFreeElement = 2; dtor_func_t pDestructor; // 析构函数 }; bucket结构分析 val 对应 HashTable 设计中的 value 始终是 zval类型（当zval是 IS_PTR类型时，可以通过 zval.</description></item></channel></rss>