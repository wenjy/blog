<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Phps on Wenjy&#39;s Blog</title><link>https://blog.wenjy.top/php/</link><description>Recent content in Phps on Wenjy&#39;s Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 11 Oct 2019 22:29:21 +0800</lastBuildDate><atom:link href="https://blog.wenjy.top/php/index.xml" rel="self" type="application/rss+xml"/><item><title>PHP7 Array</title><link>https://blog.wenjy.top/php/php7-array/</link><pubDate>Fri, 11 Oct 2019 22:29:21 +0800</pubDate><guid>https://blog.wenjy.top/php/php7-array/</guid><description>PHP7数组的实现 PHP数组是一个有序的字典，它必须同时满足下面两个语义 PHP数组是一个字典，存储着键-值（key-value）对，通过键可以快速地找到对应的值，键可以是整形、字符串。
PHP数组是有序的，这个有序是指插入顺序，即遍历数组的时候，遍历元素的顺序应该和插入的顺序一致。
为了实现语义1，PHP使用 HashTable 来存储 key-value ，但是 HashTable 只能保证语义1
php使用了带h值的 HashTable key/value -&amp;gt; hash1函数 -&amp;gt; h值 -&amp;gt; hash2函数 -&amp;gt; slotN -&amp;gt; bucket()
示意图：
bucket里面增加了 h 字段
hash函数拆分成 hash1 和 hash2 函数，hash1 将 key 映射成 h值，hash2 将 h 值映射为 slot 的索引值
bucket 里的 key 作为字符串key
HashTable 的key可能为数字，也可能是字符串，如果是数字那么 h值就代表数字key，如果是字符串，计算出h值，key1和key2比较时 先比较它们的h值是否相等，如果相等在比较key1和key2是否相等，因为大部分场景，不同字符串的h值都不会相等，这样提高了 HashTable 的插入、查找速度。
数组的基本结构 typedef struct _zend_array zend_array; typedef struct _zend_array HashTable; //Bucket：散列表中存储的元素 typedef struct _Bucket { zval val; //存储的具体value，这里嵌入了一个zval，而不是一个指针 zend_ulong h; //key根据times 33计算得到的哈希值，或者是数值索引编号 zend_string *key; //存储元素的key } Bucket; //HashTable结构 typedef struct _zend_array HashTable; struct _zend_array { zend_refcounted_h gc; // 引用计数相关 union { struct { ZEND_ENDIAN_LOHI_4( zend_uchar flags, // zend_uchar nApplyCount, // 递归遍历计数，为了解决循环引用导致死循环的问题 zend_uchar nIteratorsCount, // 迭代器计数器 zend_uchar reserve) } v; uint32_t flags; } u; uint32_t nTableMask; //哈希值计算掩码，等于nTableSize的负值(nTableMask = -nTableSize) Bucket *arData; //存储元素数组，指向第一个Bucket（连续的内存） uint32_t nNumUsed; //已用Bucket数 uint32_t nNumOfElements; //哈希表有效元素数 uint32_t nTableSize; //哈希表总大小，为2的n次方 uint32_t nInternalPointer; // 全局游标 与 reset/key/current/next/prev函数有关 zend_long nNextFreeElement; //下一个可用的数值索引,如:arr[] = 1;arr[&amp;quot;a&amp;quot;] = 2;arr[] = 3; 则nNextFreeElement = 2; dtor_func_t pDestructor; // 析构函数 }; bucket结构分析 val 对应 HashTable 设计中的 value 始终是 zval类型（当zval是 IS_PTR类型时，可以通过 zval.</description></item></channel></rss>