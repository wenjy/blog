---
title: "TCP协议"
keywords: "TCP协议"
description: "TCP协议"
date: 2020-12-27T20:53:12+08:00
tags: ["TCP", "Network"]
categories: ["TCP"]
reprintPolicy: noreprint
---

## TCP协议

学习《计算机网络》

> TCP是面向连接的传输层协议，需建立连接，数据传输完毕后必须释放已建立的连接

> 每条TCP连接只能有两个端点，点对点。连接的端点叫做**套接字**（socket），由IP+端口和冒号组成。

>TCP提供可靠交付的服务，无差错、不丢失、不重复、并且按序到达。

> 提供**全双工通信**，TCP连接的两端都设有发送和接收缓存，应用程序只需要把数据传送给TCP，具体数据发送由TCP来决定，接收时，TCP把收到
的数据放入缓存，上层应用在合适的时候读取缓存中的数据。

> 面向字节流（stream），流入进程或从进程流出的字节序列。TCP把应用程序交下拉的数据看成仅仅是一串**无结构的字节流**，并不要知道其中的含义，
>不保证接收应用收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。

### 停止等待协议

> 每发送完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组。

#### 自动重传请求ARQ（Automatic Repeat Request）

这里讨论由A向B发送数据，B回复确认的单向通信。

- 无差错

假定数据传输只在一个方向进行。
A发送分组M1，发送完就暂停，等待B的确认，B收到M1就向A发送确认。

- 出差错

B接收M1是检测出了差错，就丢弃M1，其他什么都不做。因为A只要超过一段时间没有收到B的确认，就认为刚发送的分组丢失，
因而重传前面发送过的分组，这叫**超时重传**。要实现超时重传，需要在每发送一个分组就设置一个**超时计时器**。如果在
超时计时器到期之前收到了对方的确认，就撤销已经设置的超时计时器。

1、A在发送完一个分组后，须暂时保留以发送的分组副本（重传可能需要使用），收到确认后才能清除副本。

2、分组和确认分组都必须进行编号，这样才能明确是哪一个分组收到了确认。

3、超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些，如果设置的很长，那么通信效率就会很低，如果设置很短，就会产生很多不必要的重传，浪费网络资源

- 确认丢失和确认迟到

A在设定的超时重传时间内没有收到确认，但这时并无法确定是自己发送的分组出错、丢失，还是B发送的确认丢失。因此A要重传此分组。

1、确认丢失，假设B又收到了重传的分组M1，则B应丢弃这个分组，并向A发送确认M1，不能认为已经发送过确认就不再发送，
因为A之所以重传M1，就是表示A没有收到M1的确认。

2、确认迟到，A会收到重复的确认，A只需要丢弃这个重复的确认

### 流水线传输

> 发送方可以连续发送多个分组，不必没发完一个就停下来等待对方的确认，这样可以提供信道利用率。

### TCP报文段首部格式

TCP是面向字节流的，但TCP传输的数据单元是报文段。TCP报文首部的前20个字节是固定的，后面4n字节是动态增加。

![TCP报文段的首部格式](/images/tcp_header.jpeg)

1、**源端口**和**目的端口**各2个字节。

2、**序号**4个字节，0 - 2^32 - 1，每个字节都按按顺序编号，保存本报文第一个字节的序号。

3、**确认号**4个字节，是期望收到对方下一个报文的第一个数据字节的序号。若确认号=N，则表明：到序号N-1为止的所有数据都已正确收到。

4、**数据偏移**4位，TCP报文的数据起始距离TCP保报文的起始处有多远，是值TCP报文段的首部长度，单位是32位字（4个字节为单位），1111 = 15，15*4=60字节，
这也就是TCP首部的最大长度，可选的长度不超过40字节。

5、**保留**6位，暂未使用，目前为0

6、 **紧急URG**（URGent）

URG=1时，字段有效，此报文需紧急传输，不需要按原来的排队顺序，如用户从键盘发送的中断命令（Control+C），
把紧急数据插到本报文的最前面，后面接着普通数据，与**紧急指针**（Urgent Pointer）配合使用。

7、**确认ACK**（Ackonwlegment）

ACK=1时，字段有效，TCP规定，在建立连接后的所有传输报文段都必须把ACK置1。

8、**推送PSH**（Push）

希望在键入一个命令后，立即就能够收到对方的响应，发送方把PSH置1，并立即创建一个报文发送出去；接收方TCP收到PSH=1的报文段，
就尽快交付接收应用进程，不用等到缓存都填满才上向上交付。

9、**复位RST**（Reset）

表明TCP立即中出现严重差错（如主机奔溃等），必须释放连接，然后再重新建立连接，RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接。

10、**同步SYN**（Synchronization）

建立连接是用来同步序号，当SYN=1 ACK=0时表明这是一个连接请求报文，若对方同意建立连接则响应的报文 SYN=1 ACK=1

11、**终止FIN**（）finish

用来释放连接，FIN=1 表明此报文段的发送方的数据已经发送完毕，并要求释放连接

12、**窗口**2字节，0 - 2^16 -1 的整数

窗口指的是发送本报文段的一方的**接收窗口**（不是自己的发送窗口），告诉对方从本报文段首部中的确认号算起，接收方目前
允许对方发送的数据数量。因为接收方的数据缓存空间时有限的。
窗口字段明确指出了现在允许对方发送的数据量，窗口值是经常动态变化

13、**检验和**checksum 2字节

检验和字段检验的范围包括首部和数据这两部分，和UDP数据一样，在计算检验和时，要在TCP报文的前面加上12字节的伪首部。
伪首部的数据都是从IP数据报头获取。
伪首部中4个字节保存源IP信息，4个字节目的IP信息，一个字节的保留位置，一个字节保存协议号（6代表TCP，17代表UDP），2个字节保存TCP的真正首部和数据。
根据伪首部的信息通过位运算，得到了一个校验和数据，保存在TCP报文的checksum字段。
接收端接收到TCP报文后，也按照特定算法计算出一个校验和，与checksum保存的校验和比较，如果相同，则完成此报文的接收。如果不相同，则丢弃此报文，让发送端重传

TCP校验和与IP校验和的区别是：TCP和UDP检验和覆盖首部和数据，而IP首部中的检验和只覆盖IP的首部，不覆盖IP数据报中的任何数据。

TCP校验和和UDP校验和的区别是：TCP的检验和是必需的，而UDP的检验和是可选的。

校验和算法：
首先，把伪首部、TCP报头、TCP数据分为16位的字，如果总长度为奇数个字节，则在最后增添一个位都为0的字节。
把TCP报头中的校验和字段置为0（否则就陷入鸡生蛋还是蛋生鸡的问题）。
其次，用反码相加法累加所有的16位字（进位也要累加），最后，对计算结果取反，作为TCP的校验和。

发送方：原码相加，并将高位叠加到低位，取反 ，得到反码求和结果，放入校验和
接收方：将所有原码 相加，高位叠加， 如全为1，则正确

14、**紧急指针**2个字节，URG=1时有效，指出紧急数据的末尾在报文段中的位置，窗口为0也可以发生紧急数据。

15、**选项**长度可变，最长40个字节。

最初TCP只规定了一种选项，即**最大报文段长度MSS**（Maximum Segment Size）,MSS是每一个TCP报文段中的数据字段的最大长度。
MSS太小，网络利用率低，太大的话，在IP层就可能被分片，因此在IP层不分片的前提下，尽可能的大。
在建立连接的过程中，双方都把自己能够支持的MSS写入这一字段，以后安装这个数值进行传递，两个方向可以有不同的MSS值。
默认为536字节，536+20=556，主机都应支持这一报文长度。

**窗口扩大选项**3个字节，窗口长度为2字节，最大为64k，对于带宽很大的网络不够用，其中一个字节为位移值S，位移值允许使用的最大值是14位，
最大窗口为 2^(16+14)，窗口扩大选项在建立连接时协商，当不需要时可以发生S=0的选项关闭

**时间戳选项**10字节，时间戳字段4字节、时间戳回送回答字段4字节，用于计算往返时间RTT和处理TCP序号超过2^32的情况，防止序号绕回。

、时间戳选项、选择确认（SACK）

### 连续ARQ协议

> 发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置，接收方可以采用积累确认的方式，对按序到达的最后一个分组进行确认，
>这就表示，到这个分组为止的所有分组都已正确收到。

积累确认的优点是容易实现，缺点是不能向发送方反映出接收方已正确收到的所有分组信息。例如，如果发送方发送了5个分组，
中间的第3个分组丢失，这时接收方只能多前2个分组发出确认，发送方无法置顶第3个分组的下落，只好把3-5分组都进行重传。
所以在通信线路质量不好时，连续ARQ协议会带来负面影响。

### 滑动窗口协议

> 位于发送窗口的分组都可以连续发送出去，不需要等待对方的确认。

滑动窗口是以字节为单位的，描述一个发生窗口的状态需要3个指针：P1、P2、P3
小于 P1 已经发送并收到确认的
P1 - P2 已发送但未收到
P2 - P3 允许发送但尚未发送的，可用窗口
大于 P3 不允许发送的部分

窗口与缓存空间

缓存是循环使用的，类似圆环结构

发送缓存：发送应用程序传输给发送方TCP准备发送的数据，TCP已发送但尚未收到确认的数据

接收缓存：按序到达的、尚未被接收应用程序读取的数据、未按序到达的数据

A的发送窗口并不一定总是和B的接收窗口一样大，因为网络会滞后

对于不按序到达数据怎么处理，统一丢弃管理简单但是对网络利用不利，一般是临时缓存在接收窗口

TCP要求接收方必须有积累确认的功能，接收方可以在合适的时候发送确认，也可以在自己有数据要发送的时候把确认信息捎带上。
接收方不应过分推迟确认，TCP规定不应超过0.5s，若接收一连串很大的报文段，需每隔一个报文段就发送一个确认。

### 超时重传时间

采用一种自适应算法，记录一个报文的发出时间，以及收到相应的确认时间，这两个时差就是报文的往返时间RTT。
TCP保留了RTT的一个加权平均往返时间 RTTs

新RTTs = (1-α) * 旧RTTs + α * 新RTT，推荐α=1/8=0.125

超时**重传时间RTO**应略大于RTTs，建议 
RTO = RTTs + 4 * RTTd

RTTd 是RTT的偏差的加权平均值

第一次测量时，RTTd值取RTT的一半
新RTTd = (1-β) * 旧RTTd + β * |RTTs - 新RTT|，推荐β=1/4=0.25

如果重传报文也计算的话，会导致数值偏大，所以报文重传了就不采用此RTT样本，这样得出的加权平均RTTs RTO比较准确。

报文段时延突然增大，出现重传，如果不计算，那么超时重传时间就得不到更新，所以报文每重传一次RTO就增大一些，典型的是取2倍旧RTO


