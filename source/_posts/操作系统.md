---
title: 操作系统
date: 2020-11-22 19:38:47
tags: 操作系统
categories: 操作系统
reprintPolicy: noreprint
---

# 学习《操作系统之哲学原理》

记录一些学习笔记

## 操作系统历史

### 1. 状态机

> 根据特定输入和现在的特定状态进行转态转换，只能做加减法运算。

### 2. 单一操作员单一控制端操作系统

> 输入一个命令就执行一个函数库，提供了简单的标准命令供以后使用。

### 3. 批处理操作系统

> 计算器总是在等待人的命令，工作效率低下，浪费了昂贵的计算机资源，于是考虑将命令打印在纸带上，
> 然后交给一个工作人员来一批批处理，把运行结果存储到磁盘上。

### 4. 多道批处理操作系统

> CPU和I/O设备的运行是串行的，在程序进行输入输出时，CPU只能等待。CPU需要不断询问I/O是否完成。
> 让CPU和I/O并行运行，这就是初衷。

### 5. 分时操作系统

> 将程序制作在卡片上，交给管理员来运行，用户无法及时获知程序运行的结果，还有可能管理员会忘记你的程序。
> 资源公平管理，每个用户可以提交自己的任务。

### 6. 现代操作系统

> 个人机开始出现，网络开始普及。此时操作系统各项功能都比较完善了。

> 内核：系统调度、调度、内存管理、进程管理、VFS框架、内核锁定、时钟和计时器、中断管理、引导、启动、
>陷阱管理、CPU管理；可装入模块：调度类、文件系统、可加载系统调用、可执行文件格式、流模块、设备、总线驱动程序等。


## 计算机硬件

> 一根总线，其它各种设备挂在总线上，这些设备都有一个控制设备，外部设备都由这些控制器与CPU通信，
> 这些设备之间的通信需通过总线。

- 存储架构

存储|平均访问延迟|平均容量
---|---|---
寄存器|1 nsec|< 1KB
缓存|2 nsec|32MB
主存|10 nsec|128MB ~ 64GB
SSD|20 usec|40GB ~ 2TB
磁盘(转动)|10 msec|40GB ~ 2TB
磁带|100 sec|40GB ~ 500GB

## 一些概念介绍

- ### 中断

> 设备在完成自己的任务后向CPU发出中断，CPU判断优先级，然后确定是否响应。如果响应，则只需中断服务程序，
>并在中断服务程序执行完后继续执行原来的程序。（中断又可以发生中断，中断分为硬件中断、软件中断）

- ### 内核态、用户态

> 为了区分不同程序的不同权限。内核态就是拥有资源多的状态，也称为特权态，用户态访问资源将受限。
> 运行在内核态的程序可靠性要求、安全性、维护性都要求高，用户态的程序编写相对就比较简单，一般来说
> 能运行用户态就能完成任务的，就应该运行在用户态。

> 所谓的用户态、内核态实际上是处理器的一种状态，而不是程序状态。通过设置该状态字，可以将CPU设置为内核态、用户态
> 或者其他的子态。一个程序运行时，CPU是什么态，这个程序就运行在什么态。

- ### 进程、内存、文件

> 一个程序一旦在计算机运行，它就成为了一个进程。操作系统对进程的管理通过进程表来实现，进程表里存放关于进程的一切信息。
> 进程的全部资源，包括内存、内核数据结构、软件资源形成一个进程核(core)，核快照（core image）代表某一时刻进程的状态。
> Linux系统下出现分段错误（segmentation fault）时，操作系统会自动进行核导出（core dump）。

- ### 系统调用(system call)

> 用户程序通过系统调用API来获得操作系统的各种服务。

系统调用按照功能可以划分为6大类：

1. 进程控制类
2. 文件管理类
3. 设备管理类
4. 内存管理类
5. 信息维护类
6. 通信类

调用一般步骤：

```
result=read(fd,buffer,nbytes);
```
这个read函数是C语言提供的库函数，这个函数然后调用操作系统的read系统调用

1、参数准备阶段

> 将所需的参数压入栈，然后调用read库函数，read库函数将read系统调用的代码放在一个约定好的寄存器里，
通过陷入（trap，一种中断方式）将控制权交给操作系统。

2、系统调用识别阶段

> 操作系统获得控制权后，将系统调用代码从寄存器取出，与操作系统维护的一张系统调用表进行比较，获得read系统调用的
>程序体所在的内存地址。之后跳到该地址。

3、系统调用执行阶段

> 执行系统调用函数，执行完毕后返回到用户程序。

- 系统调用中的参数传递

> 上面是将参数压入栈中，其实在x64结构，最前面的8个参数由寄存器传递，只有超过8个参数时，后面的参数才通过栈来传递。

- ### CPU指令集

1、X86

> 是微处理器执行的计算机语言指令集，指一个intel通用计算机系列的标准编号缩写，也标识一套通用的计算机指令集合，属于CISC。

2、X64

> 又叫`x86-64`，简称为`x64`，是64位微处理器架构及其相应指令集的一种，也是Intel x86架构的延伸产品，也是属于CISC。
> 由AMD设计，后来改名为AMD64，主要是与X86兼容

3、ARM

> 曾称进阶精简指令集机器（Advanced RISC Machine）更早称作Acorn RISC Machine，是一个32位精简指令集（RISC）处理器架构。

- ### 壳（shell）

> 便于于用户交互，可以是图形界面也可以是文本界面，用户在界面上输入命令，操作系统则执行这些命令。

## 进程

进程=程序+执行

> 操作系统对CPU进行管理的重要手段就是进程模型。进程出现的动机是渴望并发，由于需要进程进行分离存储而导致
>出现内存管理；由于需要让不同的进程有序的推进，又出现了进程调度。
>进程从根本上来说是操作系统对CPU进行的抽象和装扮，因为并发所以发明了进程。

- ### 进程模型

> 从物理内存的分配看来，每个进程占用一片内存空间，进程就是内存的某片空间，由于在任意时刻CPU只能执行一条指令，
>所以任意时刻在CPU上执行的进程只有一个，而到底执行那条指令由物理程序寄存器指定。

- 进程状态

执行态、阻塞态、就绪态

- ### 进程管理

进程表：寄存器、程序计数器、状态字、栈指针、优先级、进程ID、信号、创建时间、所耗CPU时间，当前持有的各种句柄等。

- 进程创建过程

1、分配进程控制块
2、初始化机器寄存器
3、初始化页表
4、将程序代码从磁盘读进内存
5、将处理器状态设置为"用户态"
6、跳转到程序的起始地址（设置程序计数器）

ps：第6步跳转指令是内核态指令，第5步时已经设置为用户态，所以这两步需要硬件帮忙作为一个步骤完成。

- 进程的缺点

只能在同一时间做一件事情，如果阻塞了，进程就会被挂起，无法执行，线程的出现是为了解决上面的问题。

## 进程调度

调度是操作系统实现进程模型的根本手段

一般程序使用CPU的模式有3种，计算密集型、IO密集型、介于两者之间

> CPU调度就是要达到极小化平均响应时间，极大化系统吞吐率、保持系统各个功能部件处于繁忙状态、提供某种貌似公平的机制。

- ### 先来先服务调度算法 `FCFS`（First Come First Serve）

> 不能抢占，一个程序一旦启动就一直运行到结束或者阻塞为止。优点是实现简单，缺点是短的工作可能变得很慢，因为前面可能有长时间的工作。

- ### 时间片轮转算法

> 主要针对`FCFS`的改进，改善短程序的响应时间。周期性的进行进程切换。系统响应时间依赖于时间片的选择（有可能比`FCFS`还慢）。

- ### 短任务优先算法 `STCF`（Shorted time to Completion Fist）

> 程序有优先级的区分，短任务的优先级比长任务高。分为非抢占和抢占两个变种，缺点：可能造成长程序无法得到CPU时间而导致"饥饿"。

- ### 优先级调度算法 

> 每个进程都有优先级，不止短和长两种优先级。动态调节优先级可以避免低优先级的进程"饥饿"，缺点：响应时间不能保证

- ### 混合调度算法 

> 将所有的进程分成不同的大类，每个大类为一个优先级。如果两个进程处于不同的大类，处于高优先级的进程先执行；
> 如果两个进程处于同一大类，则采用时间片轮转算法

- ### 其他调度算法 

保证调度（Guaranteed Scheduling）
彩票调度（Lottery Scheduling）
用户公平调度（Fair Share Scheduling Per User）

- ### 实时调度算法

> 动态优先调度（EDF Earliest Deadline First）、静态优先调度（RMS Rate Monotonic Scheduling）

EDF就是最早截止的任务先做，如果新工作来了，比正在进行的程序的截止时间更早，那么就抢占当前进程。

RMS 在进行调度钱先计算出所有任务的优先级，然后按照优先级进行调度，任务执行中既不接收新的进程，也不进行优先级调整和CPU抢占。

## 进程调度的过程

- 因时序或外部知道或进程挂起而导致操作系统获得CPU权限

- 操作系统在所有就绪的进程中按照某种算法选中进程

- 如果选中的是非当前进程，则操作系统将当前进程（中断或挂起的进程）状态予以保护。

- 将选中的进程环境设置好（设置寄存器、栈指针、状态字等）

- 跳转到选中的进程。

## 调度异常之优先级倒挂（priority inversion）

> 指的是一个低优先级任务持有一个被高优先级认为所需要的共享资源。这样高优先级的任务因为资源缺乏而处于受阻状态，
> 一直到低优先级任务释放资源为止。如果此时有其他优先级介于二者之间的任务，并且不需要这个共享资源，则该中介优先级的进程
> 将获得CPU控制权，从而超越了这两个任务，导致高优先级进程被临界区外的低优先级进程阻塞。

解决办法

- 使用中断禁止

通过禁止中断来保护临界区，多CPU环境下使用 单一共享标志锁（旋锁）

- 优先级上限

- 优先级继承

## 进程通信

- ### 管道

> 在某种存储介质上划出一片空间，赋给其中一个进程写权限，另一个进程读权限。`|`，管道的一个重要特点是使用管道的两个进程之间必须存在某种关系（父子），
> 如果要在两个不相关进程之间使用管道，则需要使用记名管道。

- ### 套接字（socket）

按传输媒介可分为 本地套接字(unix)、网域套接字

网域套接字按数据传输特性分为：

- 数据流（stream）

双向、有序、可靠、非重复数据通信 TCP

- 电报流（datagram）

双向，不一定有序，尽最大可能交付 UDP

- 序列包（sequential） 

双向、有序、可靠、面向连接、固定最大长度的数据通信，数据端通过接收每一个数据段来读取整个数据包

- 裸套接字（raw）

提供读取原始的网络协议。这种特殊的套接字可用于手工构建任意类型的协议 ICMP

- rdm 

提供一个可靠的数据层，但不保证到达顺序。一般的操作系统都未实现此功能。

server socket bind listen accept read write
client socket connect read write

- ### 信号（signal）

> 迫使一方对我们的通信立即做出回应，不用建立连接，而是临时决定要与某个进程通信，传输的信息量很小，消耗资源小

- ### 信号量（semaphore）

> 信号量来源于铁路信号系统，相当于旗语，简单的用0 1表示，信号量不止是通信机制，也是一种同步机制

- ### 共享内存

> 两个进程需要共享大量的数据，进程的拥抱

- ### 消息队列

> 相比管道，无需限制进程，任何进程都可以读写，多对多

## 线程

> 进程属于处理器级并发，既在处理器这一层次上提供并发的抽象；线程则属于进程级别并发，既在进程这个层次上再次提供一次并发抽象。
> 将进程分解为线程还可以有效的利用多处理器和多核，可以让不同线程同时运行在不同处理器上。

### 线程管理

线程控制表

如果某资源不独享会导致线程运行错误，则该资源就由每个线程独享；而其他资源都由进程里面所有线程共享。

共享：地址空间、全局变量、文件、子进程、定时器、信号等

不共享：程序计数器、寄存器、栈、状态字

结合用户态和内核态线程模型，用户态的执行系统负责进程内部线程在非阻塞时的切换，内核态的操作系统负责阻塞线程的切换。
其中内核态的线程较少，用户态的线程数量多，每个内核态线程可以服务多个用户态线程。

- 线程同步

线程同步的目的就是不管线程之间的执行如何穿插，其运行结果都是正确的，或者说保证多线程执行下的结果确定性。
