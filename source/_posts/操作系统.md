---
title: 操作系统
date: 2020-11-22 19:38:47
tags: 操作系统
categories: 操作系统
reprintPolicy: noreprint
---

# 学习《操作系统之哲学原理》

记录一些学习笔记

## 操作系统历史

### 1. 状态机

> 根据特定输入和现在的特定状态进行转态转换，只能做加减法运算。

### 2. 单一操作员单一控制端操作系统

> 输入一个命令就执行一个函数库，提供了简单的标准命令供以后使用。

### 3. 批处理操作系统

> 计算器总是在等待人的命令，工作效率低下，浪费了昂贵的计算机资源，于是考虑将命令打印在纸带上，
> 然后交给一个工作人员来一批批处理，把运行结果存储到磁盘上。

### 4. 多道批处理操作系统

> CPU和I/O设备的运行是串行的，在程序进行输入输出时，CPU只能等待。CPU需要不断询问I/O是否完成。
> 让CPU和I/O并行运行，这就是初衷。

### 5. 分时操作系统

> 将程序制作在卡片上，交给管理员来运行，用户无法及时获知程序运行的结果，还有可能管理员会忘记你的程序。
> 资源公平管理，每个用户可以提交自己的任务。

### 6. 现代操作系统

> 个人机开始出现，网络开始普及。此时操作系统各项功能都比较完善了。

> 内核：系统调度、调度、内存管理、进程管理、VFS框架、内核锁定、时钟和计时器、中断管理、引导、启动、
>陷阱管理、CPU管理；可装入模块：调度类、文件系统、可加载系统调用、可执行文件格式、流模块、设备、总线驱动程序等。


## 计算机硬件

> 一根总线，其它各种设备挂在总线上，这些设备都有一个控制设备，外部设备都由这些控制器与CPU通信，
> 这些设备之间的通信需通过总线。

- 存储架构

存储|平均访问延迟|平均容量
---|---|---
寄存器|1 nsec|< 1KB
缓存|2 nsec|32MB
主存|10 nsec|128MB ~ 64GB
SSD|20 usec|40GB ~ 2TB
磁盘(转动)|10 msec|40GB ~ 2TB
磁带|100 sec|40GB ~ 500GB

## 一些概念介绍

- ### 中断

> 设备在完成自己的任务后向CPU发出中断，CPU判断优先级，然后确定是否响应。如果响应，则只需中断服务程序，
>并在中断服务程序执行完后继续执行原来的程序。（中断又可以发生中断，中断分为硬件中断、软件中断）

- ### 内核态、用户态

> 为了区分不同程序的不同权限。内核态就是拥有资源多的状态，也称为特权态，用户态访问资源将受限。
> 运行在内核态的程序可靠性要求、安全性、维护性都要求高，用户态的程序编写相对就比较简单，一般来说
> 能运行用户态就能完成任务的，就应该运行在用户态。

> 所谓的用户态、内核态实际上是处理器的一种状态，而不是程序状态。通过设置该状态字，可以将CPU设置为内核态、用户态
> 或者其他的子态。一个程序运行时，CPU是什么态，这个程序就运行在什么态。

- ### 进程、内存、文件

> 一个程序一旦在计算机运行，它就成为了一个进程。操作系统对进程的管理通过进程表来实现，进程表里存放关于进程的一切信息。
> 进程的全部资源，包括内存、内核数据结构、软件资源形成一个进程核(core)，核快照（core image）代表某一时刻进程的状态。
> Linux系统下出现分段错误（segmentation fault）时，操作系统会自动进行核导出（core dump）。

- ### 系统调用(system call)

> 用户程序通过系统调用API来获得操作系统的各种服务。

系统调用按照功能可以划分为6大类：

1. 进程控制类
2. 文件管理类
3. 设备管理类
4. 内存管理类
5. 信息维护类
6. 通信类

调用一般步骤：

```
result=read(fd,buffer,nbytes);
```
这个read函数是C语言提供的库函数，这个函数然后调用操作系统的read系统调用

1、参数准备阶段

> 将所需的参数压入栈，然后调用read库函数，read库函数将read系统调用的代码放在一个约定好的寄存器里，
通过陷入（trap，一种中断方式）将控制权交给操作系统。

2、系统调用识别阶段

> 操作系统获得控制权后，将系统调用代码从寄存器取出，与操作系统维护的一张系统调用表进行比较，获得read系统调用的
>程序体所在的内存地址。之后跳到该地址。

3、系统调用执行阶段

> 执行系统调用函数，执行完毕后返回到用户程序。

- 系统调用中的参数传递

> 上面是将参数压入栈中，其实在x64结构，最前面的8个参数由寄存器传递，只有超过8个参数时，后面的参数才通过栈来传递。

- ### CPU指令集

1、X86

> 是微处理器执行的计算机语言指令集，指一个intel通用计算机系列的标准编号缩写，也标识一套通用的计算机指令集合，属于CISC。

2、X64

> 又叫`x86-64`，简称为`x64`，是64位微处理器架构及其相应指令集的一种，也是Intel x86架构的延伸产品，也是属于CISC。
> 由AMD设计，后来改名为AMD64，主要是与X86兼容

3、ARM

> 曾称进阶精简指令集机器（Advanced RISC Machine）更早称作Acorn RISC Machine，是一个32位精简指令集（RISC）处理器架构。

- ### 壳（shell）

> 便于于用户交互，可以是图形界面也可以是文本界面，用户在界面上输入命令，操作系统则执行这些命令。

## 进程

进程=程序+执行

> 操作系统对CPU进行管理的重要手段就是进程模型。进程出现的动机是渴望并发，由于需要进程进行分离存储而导致
>出现内存管理；由于需要让不同的进程有序的推进，又出现了进程调度。
>进程从根本上来说是操作系统对CPU进行的抽象和装扮，因为并发所以发明了进程。

- ### 进程模型

> 从物理内存的分配看来，每个进程占用一片内存空间，进程就是内存的某片空间，由于在任意时刻CPU只能执行一条指令，
>所以任意时刻在CPU上执行的进程只有一个，而到底执行那条指令由物理程序寄存器指定。

- 进程状态

执行态、阻塞态、就绪态

- ### 进程管理

进程表：寄存器、程序计数器、状态字、栈指针、优先级、进程ID、信号、创建时间、所耗CPU时间，当前持有的各种句柄等。

- 进程创建过程

1、分配进程控制块
2、初始化机器寄存器
3、初始化页表
4、将程序代码从磁盘读进内存
5、将处理器状态设置为"用户态"
6、跳转到程序的起始地址（设置程序计数器）

ps：第6步跳转指令是内核态指令，第5步时已经设置为用户态，所以这两步需要硬件帮忙作为一个步骤完成。

- 进程的缺点

只能在同一时间做一件事情，如果阻塞了，进程就会被挂起，无法执行，线程的出现是为了解决上面的问题。

## 进程调度

调度是操作系统实现进程模型的根本手段

一般程序使用CPU的模式有3种，计算密集型、IO密集型、介于两者之间

> CPU调度就是要达到极小化平均响应时间，极大化系统吞吐率、保持系统各个功能部件处于繁忙状态、提供某种貌似公平的机制。
