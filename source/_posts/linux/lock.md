---
url: /2020/07/16/linux-lock.html
title: "Linux Lock的发展"
keywords: "Linux,Lock的发展"
description: "Linux Lock的发展"
date: 2020-07-16T20:29:21+08:00
draft: true
tags: ["Linux"]
tags_weight: 100
categories: ["Linux"]
categoryes_weight: 100
---

《操作系统之哲学原理》-锁的发展

## 养金鱼的故事

金鱼有一个很大的特点，就是没有饱的感觉。因此，金鱼吃东西不会因为吃饱就停止，它们会不停的吃
一直到鱼缸里的食物都被吃完为止。所以，如果你一直喂，它就一直吃，直到胀死。

现在假设小明和小刚两个人合住一套公寓，共同养了一条金鱼，该金鱼一天进食一次。
两个人想把金鱼养活，一天只喂一次，也只能喂一次。如果有一天两人都喂了鱼，鱼就胀死，
如果一天内两人都没有喂鱼，鱼就饿死。

他们二人为了把鱼养好，做出如下约定：
- 每天喂鱼一次，且仅一次

- 如果今天小明喂了鱼，小刚今天就不能再喂，反之亦然

- 如果今天小明没有喂鱼，小刚就必须喂，反之亦然

### 一、不具备任何协调能力

小明与小刚不进行任何沟通，没人觉得要喂鱼时，查看一下鱼的状态，如果感觉鱼像是没有进食，则喂鱼，否则不喂

下面是给出的是在没有同步情况下的程序

小明：
```
if (noFeed) {
    feed fish
}
```
小刚：
```
if (noFeed) {
    feed fish
}
```

假设小明和小刚都是养鱼高手，一眼就能看出鱼是否喂过，上述的程序也能正确的执行吗？
答案是否定的

由于线程的执行可以任意穿插，小明可以先检查鱼，发现没有喂鱼，就准备喂鱼
但是就在小明准备喂时，程序切换，轮到小刚执行，小刚一看鱼还没喂，就喂鱼，喂完之后，线程切换到小明，
小明充检查完鱼状态的指令开始执行，于是就喂鱼，这样鱼就被喂了两次，鱼就胀死了

时序图:

时序|小明|小刚
---|---|---
1|look at fish(no feed)|
2| |look at fish(no feed)
3| |feed fish
4|feed fish|


两个或多个线程争相执行同一段代码或访问同一资源的现象称为竞争(race)。
这个可能造成竞争的共享代码段或者资源称为临界区(critical section)

### 二、第一种同步机制：留字条

要防止与胀死，就需要防止竞争，想要避免竞争，就需要防止两个或多个进程同时进入临界区
要达到这一点，就需要某种协调手段

协调的目的就是在任何时刻都只能有一个人在临界区里，这称为互斥(mutual exclusion)

互斥需要满足4个条件

- 不能有两个进程同时在临界区里面

- 进程能够在任何数量和速度的CPU上正确执行

- 在互斥区域外不能阻止另一个进程的运行

- 进程不能无限制地等待进入临界区

第一种同步方式：小明与小刚商定，每人在喂鱼之前留下字条，告诉对方自己将检查鱼，并在需要时喂鱼

小明

```
if (noNote) {
    leave note
    if (noFeed) {
        feed fish
    }
    remove note
}
```

小刚：
```
if (noNote) {
    leave note
    if (noFeed) {
        feed fish
    }
    remove note
}
```
