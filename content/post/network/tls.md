---
url: /2020/04/14/tls.html
title: "TLS握手通信"
keywords: "TLS握手通信"
description: "TLS握手通信"
date: 2020-04-14T22:53:12+08:00
draft: false
tags: ["TLS", "RSA"]
tags_weight: 100
categories: ["TLS"]
categoryes_weight: 100
---

## RSA

[阮一峰 RSA算法原理（一）](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)

[阮一峰 RSA算法原理（二）](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)

### 一些数学知识

- 质数

质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数

[百度百科 质数](https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0)

- 互质关系

如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）

互质关系的结论：
```
1. 任意两个质数构成互质关系，比如13和61。

2. 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。

3. 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。

4. 1和任意一个自然数是都是互质关系，比如1和99。

5. p是大于1的整数，则p和p-1构成互质关系，比如57和56。

6. p是大于1的奇数，则p和p-2构成互质关系，比如17和15。
```

- 欧拉函数

任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？

计算这个值的方法就叫做欧拉函数，以φ(n)表示。

分以下情况讨论

```
1. 如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。

2. 如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。

3. 如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则 φ(p^k) = p^k - p^(k-1) = p^k(1-1/p)。
例如：φ(8) = φ(2^3) = 2^3 - 2^2 = 8 - 4 = 4。

4. 如果n可以分解成两个互质的整数之积，n = p1 * p2，则 φ(n) = φ(p1p2) = φ(p1)φ(p2)

5. 任意一个大于1的正整数，都可以写成一系列质数的积。φ(n) = n(1-1/p1)(1-1/p2)...(1-1/pr)
```

- 欧拉定理

如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：`a^φ(n) ≡ 1(mod n)`

a的φ(n)次方被n除的余数为1

费马小定理：
假设正整数a与质数p互质，因为质数p的φ(p)等于p-1，则欧拉定理可以写成：`a^(p-1) ≡ 1(mod p)`

- 模反元素

如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1

`ab ≡ 1(mod n)` b叫做a的模反元素

### RSA算法

假设A与B通信

1. A随机选择两个不相等的质数p和q

这里 p=61 q=53，在实际应用中，这两个质数越大就越难破解

2. 计算p和q的乘积n

n = p*q = 61*53 = 3233

n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。
实际应用中，RSA密钥一般是1024位，重要场合则为2048位

3. 计算n的欧拉函数φ(n)

φ(n) = (p-1)(q-1) = 60*52 = 3120

4. 随机选择一个整数e，条件是1< e < φ(n)，且e与φ(n) 互质

这里选择 17，实际应用中，常常选择65537

5. 计算e对于φ(n)的模反元素d

`ed ≡ 1 (mod φ(n))` 等价于 `ed - 1 = kφ(n)`

17d - 3120k = 1 (d,k)=(2753,15) d=2753

6. 将n和e封装成公钥，n和d封装成私钥

n=3233，e=17，d=2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）

这六个数字之中，公钥用到了两个（n和e），其余四个数字都是不公开的。其中最关键的是d，因为n和d组成了私钥，一旦d泄漏，就等于私钥泄漏

有无可能在已知n和e的情况下，推导出d？

`ed≡1 (mod φ(n))`。只有知道e和φ(n)，才能算出d。

`φ(n)=(p-1)(q-1)`。只有知道p和q，才能算出φ(n)。

n=pq。只有将n因数分解，才能算出p和q。

如果n可以被因数分解，d就可以算出，也就意味着私钥被破解

对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。

假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。

只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的

- 加密和解密

假设A向B发送信息m，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n

m = 65

`m^e ≡ c (mod n)`

B的公钥是(n,e) (3233, 17)

65^17 ≡ 2790 (mod 3233)

c等于2790，于是A把2790发送给B

解密要用私钥(n,d) (3233, 2753) 

B收到2790

`cd ≡ m (mod n)`

2790^2753 ≡ 65 (mod 3233)

因此加密前的原文就是65

## TLS1.2

1. 客户端发送 ClientHello, 包含一个随机数 ClientHello.random。

2. 服务器回复 ServerHello，包含一个随机数 ServerHello.random，同时回复 certificate，携带了证书公钥P。

3. 客户端收到 ServerHello.random 之后，就能够生成 pre_master_secret 以及 master_secret。

  其中，pre_master_secret 长度为48个字节，前两个字节是协议版本号，剩下的46个字节填充一个随机数。结构如下：
  `Struct {byte Version[2]; bute random[46];}`
  
  master_secret 的生成算法简述如下：
  `master_secret = PRF(pre_master_secret, "master secret", ClientHello.random+ServerHello.random)`
  
  其中，PRF是一个随机函数，定义如下:
  `PRF(secret, label, seed) = P_MD5(S1, label + seed) XOR P_SHA-1(S2, label + seed)`
  
   而 master_secret 包含了6部分内容，分别是用于校验内容一致性的密钥，用于对称内容加解密的密钥，
   以及初始化向量(用于CBC模式)，客户端和服务器各一份，从上式可以看出，把 pre_master_secret 赋值给 secret， 
   master_key 赋值给 label，客户端和服务器的两个随机数做种子就能确定地求出一个 48位长的随机数。

4. 客户端使用证书公钥P将 pre_master_secret 加密后发送给服务器。

5. 服务器使用私钥解密得到 pre_master_secret，又由于服务端之前就接收了 ClientHello.random ，所以服务器根据相同的生成算法，在相同的输入参数下，求出了相同了 master_secret。

6. 客户端和服务器使用 master_secret 加密数据通信
