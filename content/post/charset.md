---
url: /2020/05/11/charset.html
title: "字符集和字符集编码"
date: 2020-05-12T18:31:57+08:00
draft: false
tags: ["字符集编码"]
tags_weight: 100
categories: ["字符集编码"]
categoryes_weight: 100
type: "reprinted"
---

本文转载自 [cenalulu http://cenalulu.github.io/linux/character-encoding/](http://cenalulu.github.io/linux/character-encoding/)

## 什么是字符集

在介绍字符集之前，我们先了解下为什么要有字符集。我们在计算机屏幕上看到的是实体化的文字，而在计算机存储介质中存放的实际是二进制的比特流。
那么在这两者之间的转换规则就需要一个统一的标准，否则把我们的U盘插到老板的电脑上，文档就乱码了；小伙伴QQ上传过来的文件，在我们本地打开又乱码了。
于是为了实现转换标准，各种字符集标准就出现了。简单的说字符集就规定了某个文字对应的二进制数字存放方式（编码）和某串二进制数值代表了哪个文字（解码）的转换关系。 
那么为什么会有那么多字符集标准呢？这个问题实际非常容易回答。问问自己为什么我们的插头拿到英国就不能用了呢？为什么显示器同时有DVI，VGA，HDMI，DP这么多接口呢？
很多规范和标准在最初制定时并不会意识到这将会是以后全球普适的准则，或者处于组织本身利益就想从本质上区别于现有标准。
于是，就产生了那么多具有相同效果但又不相互兼容的标准了。 

说了那么多我们来看一个实际例子，下面就是`屌`这个字在各种编码下的十六进制和二进制编码结果，怎么样有没有一种很屌的感觉？

字符集|16进制编码|对应的二进制数据
---|---|---
UTF-8|0xE5B18C|1110 0101 1011 0001 1000 1100
UTF-16|0x5C4C|1011 1000 1001 1000
GBK|0x8CC5|1000 1100 1100 0101

## 什么是字符编码

字符集只是一个规则集合的名字，对应到真实生活中，字符集就是对某种语言的称呼。例如：英语，汉语，日语。
对于一个字符集来说要正确编码转码一个字符需要三个关键元素：字库表（character repertoire）、编码字符集（coded character set）、字符编码（character encoding form）。

其中字库表是一个相当于所有可读或者可显示字符的数据库，字库表决定了整个字符集能够展现表示的所有字符的范围。
编码字符集，即用一个编码值`code point`来表示一个字符在字库中的位置。字符编码，将编码字符集和实际存储数值之间的转换关系。
一般来说都会直接将`code point`的值作为编码后的值直接存储。例如在`ASCII`中`A`在表中排第65位，而编码后`A`的数值是`0100 0001`也即十进制的65的二进制转换结果。
 
看到这里，可能很多读者都会有和我当初一样的疑问：`字库表`和`编码字符集`看来是必不可少的，那既然字库表中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。
为什么还要多此一举通过`字符编码`把序号转换成另外一种存储格式呢？

其实原因也比较容易理解：统一字库表的目的是为了能够涵盖世界上所有的字符，但实际使用过程中会发现真正用的上的字符相对整个字库表来说比例非常低。
例如中文地区的程序几乎不会需要日语字符，而一些英语国家甚至简单的`ASCII`字库表就能满足基本需求。
而如果把每个字符都用字库表中的序号来存储的话，每个字符就需要3个字节（这里以Unicode字库为例），这样对于原本用仅占一个字符的ASCII编码的英语地区国家显然是一个额外成本（存储体积是原来的三倍）。
算的直接一些，同样一块硬盘，用ASCII可以存1500篇文章，而用3字节Unicode序号存储只能存500篇。
虽然现在硬盘或者内存都很廉价，但是在网络传输中，这个问题就凸显出来了，你可以这样想想，本来1M的带宽在ANSI下可以代表1024*1024个字符，但是在Unicode下却只能代表1024*1024/2个字符。
也就是1MB/s的带宽只能等价于512KB/s，这个很可怕啊。所以为了解决符号在网络中传输的浪费问题，于是就出现了UTF-8这样的变长编码`Unicode transfer format -8`，后面的8代表是以8位二进制为单位来传输符号的
在UTF-8编码中原本只需要一个字节的ASCII字符，仍然只占一个字节。而像中文及日语这样的复杂字符就需要2个到3个字节来存储。

## 字符编码发展史

- 美国人首先对其英文字符进行了编码，也就是最早的`ASCII`码，用一个字节的低7位来表示英文的128个字符，高1位统一为0；

- 后来欧洲人发现你这128位哪够用，比如法国人字母上面的还有注音符，这个怎么区分，得，把高1位编进来吧，这样欧洲普遍使用一个全字节进行编码，最多可表示256位。

- 但是即使位数少，不同国家地区用不同的字符编码，虽然0--127表示的符号是一样的，但是128--255这一段的解释完全乱套了，即使2进制完全一样，表示的字符完全不一样，比如135在法语，希伯来语，俄语编码中完全是不同的符号；

- 更麻烦的是，电脑传到中国后，我们发现我们有10万多个汉字，你们欧美这256字塞牙缝都不够。于是就发明了GB2312这些汉字编码，典型的用2个字节来表示绝大部分的常用汉字，最多可以表示65536个汉字字符，这样就不难理解有些汉字你在新华字典里查得到，但是电脑上如果不处理一下你是显示不出来的了吧；

- 这下各用各的字符集编码，这世界咋统一？俄国人发封email给中国人，两边字符集编码不同，显示都是乱码啊。为了统一，于是就发明了Unicode，将世界上所有的符号都纳入其中，每一个符号都给予一个独一无二的编码，现在unicode可以容纳100多万个符号，每个符号的编码都不一样，这下可统一了，所有语言都可以互通，一个网页页面里可以同时显示各国文字。

- 然而，unicode虽然统一了全世界字符的二进制编码，但没有规定如何存储啊，亲。x86和amd体系结构的电脑小端序和大端序都分不清，别提计算机如何识别到底是Unicode还是ASCII了。如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，文本文件的大小会因此大出二三倍，这对于存储来说是极大的浪费。这样导致一个后果：出现了Unicode的多种存储方式。

- 互联网的兴起，网页上要显示各种字符，必须统一啊，UTF-8就是Unicode最重要的实现方式之一。另外还有UTF-16、UTF-32等。UTF-8不是固定字长编码的，而是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。

## UTF-8和Unicode的关系

看完上面的概念解释，那么解释UTF-8和Unicode的关系就比较简单了。Unicode就是上文中提到的编码字符集，而UTF-8就是字符编码，即Unicode规则字库的一种实现形式。
随着互联网的发展，对同一字库集的要求越来越迫切，Unicode标准也就自然而然的出现。它几乎涵盖了各个国家语言可能出现的符号和文字，并将为他们编号。
详见：[Unicode on Wikipedia](https://en.wikipedia.org/wiki/Unicode)。Unicode的编号从`0000`开始一直到`10FFFF`共分为17个Plane，每个Plane中有65536个字符。

而UTF-8则只实现了第一个Plane，可见UTF-8虽然是一个当今接受度最广的字符集编码，但是它并没有涵盖整个Unicode的字库，这也造成了它在某些场景下对于特殊字符的处理困难（下文会有提到）。

## UTF-8编码简介

为了更好的理解后面的实际应用，我们这里简单的介绍下UTF-8的编码实现方法。即UTF-8的物理存储和Unicode序号的转换关系。 

UTF-8编码为变长编码。最小编码单位（`code unit`）为一个字节。一个字节的前1-3个bit为描述性部分，后面为实际序号部分。

1. 如果一个字节的第一位为0，那么代表当前字符为单字节字符，占用一个字节的空间。0之后的所有部分（7个bit）代表在Unicode中的序号。

2. 如果一个字节以110开头，那么代表当前字符为双字节字符，占用2个字节的空间。110之后的所有部分（5个bit）加上后一个字节的除10外的部分（6个bit）代表在Unicode中的序号。且第二个字节以10开头

3. 如果一个字节以1110开头，那么代表当前字符为三字节字符，占用3个字节的空间。110之后的所有部分（5个bit）加上后两个字节的除10外的部分（12个bit）代表在Unicode中的序号。且第二、第三个字节以10开头

4. 如果一个字节以10开头，那么代表当前字节为多字节字符的第二个字节。10之后的所有部分（6个bit）和之前的部分一同组成在Unicode中的序号。

具体每个字节的特征可见下表，其中`x`代表序号部分，把各个字节中的所有`x`部分拼接在一起就组成了在Unicode字库中的序号

Byte 1|Byte 2|Byte 3
---|---|---
0xxx xxxx||
110x xxxx|10xx xxxx|
1110 xxxx|10xx xxxx|10xx xxxx

我们分别看三个从一个字节到三个字节的UTF-8编码例子：

实际字符|在Unicode字库序号的十六进制|在Unicode字库序号的二进制|UTF-8编码后的二进制|UTF-8编码后的十六进制
---|---|---|---|---
$|0024|010 0100|0010 0100|24
¢|00A2|000 1010 0010|1100 0010 1010 0010|C2 A2
€|20AC|0010 0000 1010 1100|1110 0010 1000 0010 1010 1100|E2 82 AC

细心的读者不难从以上的简单介绍中得出以下规律：

1. 3个字节的UTF-8十六进制编码一定是以`E`开头的

2. 2个字节的UTF-8十六进制编码一定是以`C`或`D`开头的

3. 1个字节的UTF-8十六进制编码一定是以比`8`小的数字开头的

## 为什么会出现乱码

`乱码`也就是英文常说的`mojibake`（由日语的`文字化け`音译）。 简单的说乱码的出现是因为：编码和解码时用了不同或者不兼容的字符集。
对应到真实生活中，就好比是一个英国人为了表示祝福在纸上写了`bless`（编码过程）。而一个法国人拿到了这张纸，由于在法语中bless表示受伤的意思，所以认为他想表达的是`受伤`（解码过程）。
这个就是一个现实生活中的乱码情况。在计算机科学中一样，一个用UTF-8编码后的字符，用GBK去解码。
由于两个字符集的字库表不一样，同一个汉字在两个字符表的位置也不同，最终就会出现乱码。
 
我们来看一个例子：假设我们用UTF-8编码存储`很屌`两个字，会有如下转换：

字符|UTF-8编码后的十六进制
---|---
很|E5BE88
屌|E5B18C

于是我们得到了`E5BE88E5B18C`这么一串数值。而显示时我们用GBK解码进行展示，通过查表我们获得以下信息：

两个字节的十六进制数值|GBK解码后对应的字符
---|---
E5BE|寰
88E5|堝
B18C|睂

解码后我们就得到了`寰堝睂`这么一个错误的结果，更要命的是连字符个数都变了。

## 如何识别乱码的本来想要表达的文字

要从乱码字符中反解出原来的正确文字需要对各个字符集编码规则有较为深刻的掌握。但是原理很简单，这里用最常见的UTF-8被错误用GBK展示时的乱码为例，来说明具体反解和识别过程。

### 第1步 编码

假设我们在页面上看到`寰堝睂`这样的乱码，而又得知我们的浏览器当前使用GBK编码。那么第一步我们就能先通过GBK把乱码编码成二进制表达式。
当然查表编码效率很低，我们也可以用以下SQL语句直接通过MySQL客户端来做编码工作：

```mysql
mysql [localhost] {msandbox} > select hex(convert('寰堝睂' using gbk));
+-------------------------------------+
| hex(convert('寰堝睂' using gbk))    |
+-------------------------------------+
| E5BE88E5B18C                        |
+-------------------------------------+
1 row in set (0.01 sec)
```

### 第2步 识别

现在我们得到了解码后的二进制字符串`E5BE88E5B18C`。然后我们将它按字节拆开。

Byte1|Byte2|Byte3|Byte4|Byte5|Byte6
---|---|---|---|---|---
E5|BE|88|E5|B1|8C

然后套用之前UTF-8编码介绍章节中总结出的规律，就不难发现这6个字节的数据符合UTF-8编码规则。
如果整个数据流都符合这个规则的话，我们就能大胆假设乱码之前的编码字符集是UTF-8

### 第3步 解码

然后我们就能拿着`E5BE88E5B18C`用UTF-8解码，查看乱码前的文字了。当然我们可以不查表直接通过SQL获得结果：

```mysql
mysql [localhost] {msandbox} ((none)) > select convert(0xE5BE88E5B18C using utf8);
+------------------------------------+
| convert(0xE5BE88E5B18C using utf8) |
+------------------------------------+
| 很屌                               |
+------------------------------------+
1 row in set (0.00 sec)
```

## 常见问题处理之Emoji

所谓Emoji就是一种在Unicode位于`\u1F601-\u1F64F`区段的字符。这个显然超过了目前常用的UTF-8字符集的编码范围`\u0000-\uFFFF`。
Emoji表情随着IOS的普及和微信的支持越来越常见。下面就是几个常见的Emoji: &#128524; &#128526; &#128525; 那么Emoji字符表情会对我们平时的开发运维带来什么影响呢？

最常见的问题就在于将他存入MySQL数据库的时候。
一般来说MySQL数据库的默认字符集都会配置成UTF-8（三字节），而utf8mb4在5.5以后才被支持，也很少会有DBA主动将系统默认字符集改成utf8mb4。
那么问题就来了，当我们把一个需要4字节UTF-8编码才能表示的字符存入数据库的时候就会报错：
`ERROR 1366: Incorrect string value: '\xF0\x9D\x8C\x86' for column` 。 

如果认真阅读了上面的解释，那么这个报错也就不难看懂了。我们试图将一串Bytes插入到一列中，而这串Bytes的第一个字节是`\xF0`意味着这是一个四字节的UTF-8编码。
但是当MySQL表和列字符集配置为UTF-8的时候是无法存储这样的字符的，所以报了错。 
那么遇到这种情况我们如何解决呢？

有两种方式：
第一种升级MySQL到5.6或更高版本，并且将表字符集切换至utf8mb4。
第二种方法就是在把内容存入到数据库之前做一次过滤，将Emoji字符替换成一段特殊的文字编码，然后再存入数据库中。
之后从数据库获取或者前端展示时再将这段特殊文字编码转换成Emoji显示。第二种方法我们假设用`-*-1F601-*-`来替代4字节的Emoji，那么具体实现python代码可以参见[Stackoverflow](https://stackoverflow.com/questions/3220031/how-to-filter-or-replace-unicode-characters-that-would-take-more-than-3-bytes)上的回答

